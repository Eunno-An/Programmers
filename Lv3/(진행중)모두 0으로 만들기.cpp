#include <string>
#include <vector>

using namespace std;

//단순하게 정점들의 합을 봐서는 모든 트리의 가중치를 0으로 만들 수 있는지 여부를 알 수가 없다.
//왜냐하면 정점들이 연결된 간선에 대해서 수행해야 되는 것이기 때문에..

// 모든 점들의 가중치를 0으로 만들어야 하는 '최소' 연산의 개수.

// 리프 노드들을 찾아서 배열에 넣는다. 그리고 깊이 순대로 정렬한다. -> 근데 이 문제에서는 리프가 따로 안나옴.
// -> **트리의 특성을 생각해보면, 트리를 펼쳐보면 그래프 모양이 되고, 어떤 점에서 시작해서 이어진 간선을 따라서 퍼져나가는 형식으로 함수를 짜면 된다.
// -> 즉, 어떤 점을 아무거나 잡아서 그리디하게 풀면 똑같을 것 같다.
// (X)모든 리프노드들에 대해서, 주어진 연산을 루트까지 따라가서 수행한다. 

long long solution(vector<int> a, vector<vector<int>> edges) {
    long long answer = -2;
    return answer;
}
